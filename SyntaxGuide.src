//THE SOURCE PROGRAMMING LANGUAGE
//===============================

//Source is a language that compiles to the HP Prime Programming Language (HPPL for short).
//
//That's really all you need to know in general, so let's get to the meat here.
//
//You want to know about the sytax.

//THE SYNTAX
//==========

//1. FUNCTIONS

//The most important thing in your Source file is your functions. Here's what a function looks like:

function example() {
	return
}

//Note the fact that you don't need no semicolons.

//Here's a function that returns something:

function example() as int {
	return 42
}

//the "as int" is both related to strict typing and is optional. More on that later.

//Here's a function with arguments:

function example(a,b,c) {
	return
}

//Big suprise, eh?

//Arguments can be strictly typed too:

function example(a as int,b as string,c as real) {
	return
}

//2. VARIABLES

//In functions, You define variables with the local keyword.

function example() {
	local x
}

//Locals behave as you expect:

local x=2
local x,y,z

//... Except they don't.

local x,y = 1,2 //x=1 and y=2.
local a,b = "wow" //only a gets assigned a value.

//Also, typing applies here.

local x as int
local y as real = 3
local x as int,y as real = 3,4

//This works too.

local (x,y,z) as int = 7,8,9

//not that ALL variables have to be defined as local somewhere.
//Unless they're global, but more on that later.

//locals only go in functions.

//3. CURRYING

//Just a side note: This works as you would think.

a,b = b,a

//Get what's happening there?

//4. STRUCTURES

//Here's an if:

if x==2 {
	
} elseif x==3 {
	
} else {
	
}

//Here's a while:

while x<2 {

}

//Aaaaand here's a repeat:

repeat {

} until x<2

//5. DATA TYPES

//Data types correspond closely to HPPL types. They are:

data_types = [real,int,string,list,cpx,matrix]

//They are made like so:

local r as real = 1 //Numbers are reals by default.
local i as int = 3 //TODO: There's no way to keep int literals apart from real literals!
local s as string = "oh my"
local l as list = [1,2,3]
local c as cpx = [1,2] //may change in future
local m as matrix = [[1,2],[3,4]] //may change in future

//Yes, there's other HPPL types. I know.

//There are logical data types, like structs and enums. That's a thing.

//6. FOR LOOPS

//For loops are special. All for loops are foreach loops in Source.
//Even if they compile to a vanilla loop.

//Here's one that iterates over a list:

for v in lst {
	//v is the value of each element in lst.
}

//This one gives you the index as well:

for i,v in lst.pairs() {
	//i is index, v is value
}

//This one is a vanilla loop that goes from 1 to 10:

for i in range(1,10) {

}

//This one counts down from 10 to 1.

for i in range(10,1,-1) {

}

// lst.pairs() is a special function called an iterator function.
// You can define your own!

iterator myLoop() {
	for v in ["one","two","three"] {
		return v
	}
}

//There, the return statement means something different.
//The function 'returns' multiple times, so this:

for word in myLoop() {
	print(word)
}

//results in this:

for v in ["one","two","three"] {
	local word = v
	print(word)
}

//crazy, huh?

//7. Operaotrs

//This language has operators. They are:

a+b
a-b
a*b
a/b
-a //Unary subtraction.
a%b //Modulus.
a^b //Power.
a==b
a!=b
a<b
a>b
a<=b
a>=b
a and b
a or b
not a
a&b //Bitwise and.
a|b //bitwise or.
!a //bitwise not.

//This next one may be odd, but:

a~b //Concatenation. Of strings and maybe lists. This is differnet than addition in that it ignores typing.

//8. Directives

//So let's say we want a main function. One that's run when we start up.
//We make it like so:

@export
function main() {

}

//The thing in the @ is a directive. These things change how your code is parsed and compiled.

//the @export directive does what you think it does. It exports the function it's attached to.

//There are other directives. Like:

@static
@const
@varargs
@private
@typedef
@keepname
@nominify

//Maybe, one day, I'll show you what the other directives do.

//9. Global directives

//And you thought we were done with directives.

//Normally, directives are attached to something. A function, maybe, or a variable.
//Global ones are not.

@@nominify

//applies the nominify directive to EVERYTHING after it's reached in the code. It's global.

//10. Fields

//In HPPL. there are global variables. Here, they are called fields.
//You define one like so:

field x

//Simple.

//Note that fields are, by HPPL design, non-transient. Therefore, you can't assign values to them like locals.

//11. Structs

//Sometimes, you need big data. But big data isn't easy in HPPL. Well, here are structs:

struct test {
	field x
	field y=2
	
	function testFunc() {
		return this.x
	}
}

//Woah, it's almost, like, object-oriented!
//Well, it's not: Structs are actually just lists.
//In reality, x is the 1st index of the list that instances of test generate. Y? The second.
//Functions? Well, this:

local t as test = test.new()
print(t.testFunc())

//is more like this:

local t as test = test.new()
print(test.testFunc(t))

//Whoops, I forgot to tell you about .new().
//It's a constructor. You can define your own if you want.

//There is also extension:

struct test2 extends test {
	field z

	function stuff(z) {
		this.z = z
	}
}

//It's very limited though. There's no overrides, and each thing can only have one parent.

//12. Enums

enum testEnum {
	field VA,VB,VC
}

//They work like this:

print(testEnum.VA) //prints 1
print(testEnum.VB) //prints 2
print(testEnum.VC) //prints 3

//They're lie structs, I guess.

//13. Casting

//I forgot to tell you. The as operator? Usable to cast anything, anywhere:

local x as int = 2
print(x as real) //No effect in this case, but you can cast there if need be!

//14. The ?

//You can specifically make the type of a variable undefined.
//You know, as opposed to being undefined by default.

local x as ? = 2

//This way, the compiler won't mess up if it specifically wants a value of unknown type.

//Functions also work:

function wow() as ? {
	return "this could be of any data type!"
}

//15. Currying functions

function multiret() as int,int {
	return 1,2
}

//this works internally by giving you back a list and unwrapping it for you.

//You call them as such:

local x,y = multiret()

//x and y is set to 1 and 2.
//If you didn't have the y there, the 2 wouldn't be assigned to anything.

//Note that if you want a function to multiret, it's probably going to need
//to be stated as such explicitly.

//16. Some more diretives

//Remember directives? They're important.

@const

//attached to a local or field means that it's a constant. It has to be set to something
//when you make it, and said value cannot change. Consts are replaced with thier value
//on compile-time.

//@const functions take all @const vairables, and must return a @const item.

@typedef

//applied to a struct means that this struct is really another type, but with
//functions attached to it. Typdef'd structs must have 1 and only 1 field.
//The compiler uses this ariable as the 1 field, but pretends it's a real struct.

@static

//applied to a field in a struct means that it's actually a global field,
//but is acsessed by the struct's name, just lie a field is.

@nominify

//applied to a function means that, on compile, there is no minification going on;
//your resultant function will have line breaks and everything.

//@nominify can be called globally.

@@nominfy

//See?

@@minify

//turns minification back on.

@keepname

//keeps the name of a function of variable just as it is on compile, instead of
//shortening it to save space.

@@keepname
@@nokeepname

//are things too.

@export

//Didn't I tell you about export already?

@key=K

//allows you to set a user key. The thing after the = is the key you want.

@@icon=name,file

//Creates an icon. File is a link to a PNG file, NOT a set of hex digits.

@private

//Makes a field or function in a struct inacsessable to functions outside the
//struct.